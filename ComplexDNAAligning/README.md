# 复杂DNA序列比对算法

## 项目概述

本项目实现了一个高效的DNA序列比对算法，能够处理长序列和短序列的比对需求。算法基于k-mer锚点检测、动态规划延展和智能间隙填充策略，在保证比对精度的同时优化了覆盖率。

## 算法整体思路

本算法本质上是一个图匹配算法，将DNA序列比对问题转化为在序列图中寻找最优路径的问题：

1. 将参考序列和查询序列的k-mer作为图中的节点
2. 相同的k-mer之间建立连接边，形成潜在的比对锚点
3. 通过延展锚点找到连续的比对路径
4. 选择非重叠的最优路径组合，最大化覆盖率

这种图匹配方法避免了传统动态规划的二次时间复杂度，同时保持了高精度的比对质量。

## 算法核心思想

### 1. 分层策略设计

算法根据查询序列长度自适应选择不同的比对策略：

1. 长序列策略（>3000bp）：注重稳定性和全局覆盖
2. 短序列策略（≤3000bp）：注重敏感性和局部精度

### 2. 多k-mer锚点检测

使用多种k-mer大小进行锚点检测，兼顾敏感性和特异性：

- 长序列：k=[8,15]，适中采样（shift=1）
- 短序列：k=[6,8,10,12,15]，密集采样（shift=1）

### 3. 保守延展策略

对每个锚点进行双向延展，严格控制错误匹配率：

- 实时监控错误匹配率，超过阈值立即停止延展
- 正向链和反向互补链分别处理

## 详细算法实现

### 阶段一：锚点生成

```python
def seq2hashtable_multi_test(refseq, testseq, kmersize, shift):
    # 构建参考序列k-mer哈希表
    # 在查询序列和其反向互补序列中搜索匹配的k-mer
    # 返回(query_pos, ref_pos, strand, match_len)格式的锚点
```

符号说明:
- n：参考序列长度
- m：查询序列长度  
- k：k-mer数量

**时间复杂度**：O(n + m·k)


### 阶段二：锚点延展

```python
def extend_anchor(query, ref, qpos, rpos, strand, initial_len, params):
    # 左向延展
    while (边界检查 and 延展长度限制):
        if 字符匹配:
            延展长度++
        else:
            错误匹配数++
            if 错误率 > 阈值:
                break
    
    # 右向延展（同样逻辑）
```

参数设置为: 
- 短序列：延展限制80bp，错误率阈值7%
- 长序列：延展限制200bp，错误率阈值5%

符号说明: L：平均延展长度
时间复杂度：O(L)

### 阶段三：片段选择与优化
```python
def select_segments(segments, params):
    # 1. 验证所有片段的编辑距离
    # 2. 按查询位置排序
    # 3. 贪心选择非重叠片段
    # 4. 应用间隙填充策略
```

验证条件的参数设置为：
- 片段长度 ≥ 30bp
- 编辑距离率 ≤ 10%
- 无查询位置重叠

### 阶段四：间隙填充

保守的间隙填充策略，仅在精确匹配时合并片段：

```python
def gap_filling(segments, query, ref, params):
    # 起始延展：尝试将第一个片段延展至位置0
    # 片段间填充：填充小间隙（≤40bp for 短序列，≤30bp for 长序列）
    # 末尾延展：尝试将最后片段延展至序列末尾
```

## 复杂度分析

### 总的符号说明

- n：参考序列长度
- m：查询序列长度
- k：k-mer总数量
- A：锚点数量
- L：平均延展长度
- S：有效片段数量
- V：单个片段验证时间
- G：平均间隙大小

### 时间复杂度

1. 锚点生成：O(n + m·k)
   - 构建哈希表：O(n)
   - 查询匹配：O(m·k)

2. 锚点延展：O(A·L)
   - A为锚点数量，L为平均延展长度
   - 实际中A << m，L << n

3. 片段选择：O(S·log S + S·V)
   - S为有效片段数，V为验证时间
   - 排序：O(S·log S)
   - 验证：O(S·V)

4. 间隙填充：O(S·G)
   - G为平均间隙大小，通常很小

总时间复杂度：O(n + m·k + A·L + S·V)

在实际应用中，由于A << m，S << A，算法表现接近线性时间。

## 性能表现

在标准测试数据集上的表现：
- **长序列（T1）**：得分29710/29820（99.6%）
- **短序列（T2）**：得分1951/2090（93.3%）

算法在保证高精度的同时，实现了优秀的覆盖率和运行效率。

## 参数配置

所有关键参数已提取到`config.py`中，便于针对不同应用场景进行调优.

## 使用方法

直接跑`python main.py`即可.

## 总结

本算法通过图匹配的思想，结合分层策略设计、多k-mer锚点检测、保守延展和智能间隙填充，实现了高效准确的DNA序列比对。算法具有良好的时间复杂度、空间效率和实际性能，适用于各种规模的序列比对任务。
