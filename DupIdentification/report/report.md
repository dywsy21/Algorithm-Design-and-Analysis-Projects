---
title: "寻找样本DNA序列中的重复片段 实验报告"
author: "王思宇"
date: \today
using_title: true
using_table_of_content: true
---

# 寻找样本DNA序列中的重复片段 实验报告

## 项目结构

以下为树状的项目结构图, 每个文件/文件夹后附加了其用途的解释：

```
DupIdentification (11.1KB)      # 项目文件夹
├── genome_utils.py (135b)        # 有关基因组的一些辅助函数，如rev() 
├── input (2.16KB)              # 输入
│   ├── query.txt (1.38KB)        # 输入的query
│   └── reference.txt (802b)      # 输入的reference
├── main.py (3.7KB)             # 主程序
├── README.md (925b)            # 说明
├── veriplot.py (1.45KB)        # 辅助函数：验证+绘图
```

## 算法细节

本算法使用后缀自动机（Suffix Automaton）实现高效的序列匹配和重复片段检测。主要步骤包括：（设reference串的长度为r，query串的长度为q）

### 后缀自动机构建

- 为参考序列（reference）和其反向互补序列分别构建后缀自动机
- 后缀自动机是一个有向无环图（DAG），能够高效匹配所有子串
- 每次构建的时间复杂度为$O(n)$，其中n为序列长度
- 总时间复杂度为$O(r + q)$

### 最大匹配预计算

- 对于查询序列（query）中的每个位置i，计算：
  * 与参考序列的最大匹配长度（len_ref）
  * 与反向互补参考序列的最大匹配长度（len_inv）
- 记录每个位置的(max_len, inverted)元组，其中：
  * max_len：两种匹配的较大值
  * inverted：标记是否为反向互补匹配
- 总时间复杂度$O(q^2)$

### 重复片段识别

- 顺序扫描查询序列，对于每个可能的起始位置：
  1. 确定当前位置的重复片段长度（dup_len）
  2. 提取相应子串，并计算其在参考序列中的位置（考虑反向互补）
  3. 检测是否存在连续重复：
     * 比较后续位置是否为相同子串
     * 验证是否具有足够的匹配长度
     * 保持重复片段长度一致
  4. 记录重复信息：(参考起始位置，重复长度，连续次数，是否反向)
  5. 跳过已处理的重复区域，继续检测
- 总时间复杂度为$O(qr + q^2)$

### 总时间复杂度

整个算法的总时间复杂度为$O(r + q + q^2 + qr + q^2) = O(q^2)$。

## 成果展示

在算法得出结果后，我们调用veriplot中的验证及绘图函数绘制出结果，以下为示例reference和query得出的结果：

| Reference Position | Length | Consecutive Count | Inverted |
|-------------------|--------|------------------|----------|
| 0 | 402 | 1 | No |
| 352 | 50 | 3 | No |
| 352 | 48 | 1 | No |
| 330 | 70 | 3 | No |
| 298 | 102 | 1 | Yes |
| 300 | 98 | 1 | Yes |
| 400 | 400 | 1 | No |

以下为veriplot中绘图函数绘制结果：
![结果可视化](result.png)
